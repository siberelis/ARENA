<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - postprocessing - unreal bloom</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		 <link type="text/css" rel="stylesheet" href="style.css"> <!--
		<style>
		#info > * {
			max-width: 650px;
			margin-left: auto;
			margin-right: auto;
		}
		</style> -->
	</head>
	<body>

		<div>
			<canvas id="bg" width=500 height=500
			style=" position: absolute; z-index: 0;
			left: 50%; top: 53%; transform: translate(-50%, -50%);
			background-color: rgb(255, 255, 255); border-radius: 40px"></canvas>
		  
		  <canvas id="synth" width=500 height=500 
			  style=" position: absolute; z-index: 1;
			  left: 50%; top: 53%; transform: translate(-50%, -50%);
			  border:1px solid #d3d3d3; border-radius: 40px"></canvas>
		  
		  <canvas id="three" width=500 height=500
			  style=" position: absolute;
			  left: 50%; top: 53%; transform: translate(-50%, -50%);
			  z-index: 2;
			  border:1px solid #d3d3d3; border-radius: 40px"></canvas>
		   
		  </div>


		  
		  <script src=./hydra-synth.js></script>
		  <script src=./art_2.js></script>


		  <script src=./particle.js></script>


		
		<div id="container"></div>


		<!-- SBR FLOWER -->

<div onclick="delay ('index.html')" 
style="position: absolute;
left: 50%; bottom: 80.5%;
transform: translate(-50%, -50%)">
<!-- link delay -->
<script>function delay (URL) {
  setTimeout( function() { window.location = URL }, 1200 );
}
</script>

  <div class="square toggle-down" onclick="toggle()">
  <img src="arena.png" width="100" height="100"></img>
  </div>

<!-- rotate animation -->
  <script>
  
    var upClass = 'toggle-up';
    var downClass = 'toggle-down';
    
    function toggle() {
      var square = document.querySelector('.square');
      
      if (~square.className.indexOf(downClass)) {
        square.className = square.className.replace(downClass, upClass);
      } else {
            square.className = square.className.replace(upClass, downClass);
      }
      
    }
    
  </script>
		
		<!-- <div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - Bloom pass by <a href="http://eduperiment.com" target="_blank" rel="noopener">Prashant Sharma</a> and <a href="https://clara.io" target="_blank" rel="noopener">Ben Houston</a>
			<br/>
			Model: <a href="https://blog.sketchfab.com/art-spotlight-primary-ion-drive/" target="_blank" rel="noopener">Primary Ion Drive</a> by
			<a href="http://mjmurdock.com/" target="_blank" rel="noopener">Mike Murdock</a>, CC Attribution.
		</div> -->

		<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.157.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.157.0/examples/jsm/"
    }
  }
</script>

		<script type="module">

			import * as THREE from 'three';

			import Stats from 'three/addons/libs/stats.module.js';
			import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
			import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
			import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
			import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
			import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
			import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';


			let camera, stats;
			let composer, renderer, mixer, clock;

			const params = {
				threshold: 1,
				strength: 0.5,
				radius: 0,
				exposure: 1
			};

			init();

			function init() {

				const container = document.getElementById( 'three' );

				stats = new Stats();
				//container.appendChild( stats.dom );

				clock = new THREE.Clock();

				renderer = new THREE.WebGLRenderer( {
					antialias: true,
					canvas: container,
					alpha: true 
				} );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( 500, 500 );
				renderer.toneMapping = THREE.ReinhardToneMapping;
			//	container.appendChild( renderer.domElement );

				const scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 50, 500 / 500, 1, 100 );
				camera.position.set( 0, 0, 10 );
				scene.add( camera );



const hydraCanvas = document.getElementById('synth');
const hydraTexture = new THREE.CanvasTexture(hydraCanvas);

const planeGeometry = new THREE.PlaneGeometry(14, 14);
const planeMaterial = new THREE.MeshBasicMaterial({ map: hydraTexture, side: THREE.DoubleSide });
const hydraPlane = new THREE.Mesh(planeGeometry, planeMaterial);

// Move the plane back by 10 units
hydraPlane.position.z = -2.5;
//hydraPlane.rotation.y = 1.570796;


scene.add(hydraPlane);



function updateTexture() {
  hydraTexture.needsUpdate = true;
  requestAnimationFrame(updateTexture);
}

updateTexture();


























//ORBIT CONTROLS
				const controls = new OrbitControls( camera, renderer.domElement );
				controls.target.set(0, 0, 0);
				controls.enableDamping = true;
				controls.maxPolarAngle = THREE.MathUtils.degToRad(100);
				controls.minPolarAngle = THREE.MathUtils.degToRad(80);
				controls.maxAzimuthAngle = THREE.MathUtils.degToRad(10);
				controls.minAzimuthAngle = THREE.MathUtils.degToRad(-10);
				controls.minDistance = 6;
				controls.maxDistance = 8;
				controls.enableRotate = true; 
				controls.update();
    			controls.enablePan = false;
    		//	controls.enableZoom = false;

			//controls.addEventListener('end', () => {
		//	controls.reset();
		//	});

// LIGHTS
				scene.add( new THREE.AmbientLight( 0x0076d6 ) );

				const pointLight = new THREE.PointLight( 0x9649f9, 1000 );
				pointLight.position.set( 0, 15, 0);
				camera.add( pointLight );
			
				const pointLight2 = new THREE.PointLight( 0xda8f32, 1000 );
				pointLight2.position.set( -15, 0, 0);
				camera.add( pointLight2 );

				const renderScene = new RenderPass( scene, camera );

				const bloomPass = new UnrealBloomPass( new THREE.Vector2( window.innerWidth, window.innerHeight ), 1.5, 0.4, 0.85 );
				bloomPass.threshold = params.threshold;
				bloomPass.strength = params.strength;
				bloomPass.radius = params.radius;


				
				const outputPass = new OutputPass();

				composer = new EffectComposer( renderer );
				composer.addPass( renderScene );
				composer.addPass( bloomPass );
				composer.addPass( outputPass );

				// new RGBELoader().load( './sky.hdr', function ( texture ) {

				// 		texture.mapping = THREE.EquirectangularReflectionMapping;

				// 		//scene.background = texture;
				// 		scene.environment = texture;

				// 		render(); });


				new GLTFLoader().load( './mushes.glb', function ( gltf ) {

					const model = gltf.scene;

					scene.add( model );

					// mixer = new THREE.AnimationMixer( model );
					// const clip = gltf.animations[ 0 ];
					// mixer.clipAction( clip.optimize() ).play();

					// animate();



					let animations = gltf.animations;
       				 if ( animations && animations.length ) {
       				mixer = new THREE.AnimationMixer( model );
     				for ( let i = 0; i < animations.length; i ++ ) {
      				let animation = animations[ i ];
      				mixer.clipAction( animation ).play(); }	}



					  animate();



				} );

				// const gui = new GUI();

				// const bloomFolder = gui.addFolder( 'bloom' );

				// bloomFolder.add( params, 'threshold', 0.0, 1.0 ).onChange( function ( value ) {

				// 	bloomPass.threshold = Number( value );

				// } );

				// bloomFolder.add( params, 'strength', 0.0, 3.0 ).onChange( function ( value ) {

				// 	bloomPass.strength = Number( value );

				// } );

				// gui.add( params, 'radius', 0.0, 1.0 ).step( 0.01 ).onChange( function ( value ) {

				// 	bloomPass.radius = Number( value );

				// } );

				// const toneMappingFolder = gui.addFolder( 'tone mapping' );

				// toneMappingFolder.add( params, 'exposure', 0.1, 2 ).onChange( function ( value ) {

				// 	renderer.toneMappingExposure = Math.pow( value, 4.0 );

				// } );

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				const width = window.innerWidth;
				const height = window.innerHeight;

				camera.aspect = width / height;
				camera.updateProjectionMatrix();

				renderer.setSize( width, height );
				composer.setSize( width, height );

			}

			function animate() {

				requestAnimationFrame( animate );

				const delta = clock.getDelta();

				

				mixer.update( delta );

				stats.update();

				composer.render();

			}

		</script>

	</body>

</html>
